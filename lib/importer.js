// Imports
const _ = require('lodash');
const request = require('request-promise-native');

const DEFAULT_ANS_TEMPLATE = require('../resources/default.ans.template.json');
const metadata = require('./metadata');
const s3 = require('./s3');
const stats = require('./stats');
const utils = require('./utils');

// Constants
const DEFAULT_IMAGE_EXTENSIONS = ['png', 'jpg'];


const functions = {};

/**
 * Creates a video ANS object.
 *
 * @param bucket the bucket
 * @param key the key that spawned the ANS generation
 * @param defaultMetadata the array of default objects
 * @param fileMetadata the metadata object for the file
 * @param imageUrl the probable matching image URL for the key we're processing
 * @returns {Promise<{}>}
 */
functions.createVideoAns = (bucket, key, defaultMetadata, fileMetadata, imageUrl) => {

  // Calculate some values to help us with the autogenerated ANS
  const { name: filename } = utils.splitKeyToComponents(key);
  const currentDateFormatted = utils.getFormattedAnsDateForNow();
  const streamUrl = s3.createUrl(bucket, key);

  // Build a fragment for defaults for title, metatitle, and description
  // We consider this separately, so we can provide a value, but not clobber any values that
  //  may be specified in the defaults
  const titleDescriptionFragment = {
    description: {
      basic: filename
    },
    headlines: {
      basic: filename,
      meta_title: filename
    }
  };

  // Build a fragment for the stream and file-specific ANS
  const fileFragment = {
    created_date: currentDateFormatted,
    last_updated_date: currentDateFormatted,
    streams: [
      {
        url: streamUrl
      }
    ]
  };

  // Update the auto-generated ANS to include any found image
  let imageFragment = {};
  if (imageUrl) {
    imageFragment = {
      promo_items: {
        basic: {
          url: imageUrl
        }
      }
    };
  }

  // Create an array of ANS objects to merge
  const allMetadata = [
    DEFAULT_ANS_TEMPLATE, // the ANS skeleton
    titleDescriptionFragment, // the auto-generated title/description
    defaultMetadata, // the metadata from the _default.json files
    fileFragment, // the fragment specific to the video being imported
    imageFragment, // the image fragment
    fileMetadata // the file-specific metadata
  ];

  // Merge all of the ANS data into an object
  return _.merge({}, ...allMetadata);
};

/**
 * Determines if there is a coresident image file based on the specified key and generates an
 *  access URL if so
 *
 * @param bucket the bucket for the source file
 * @param key the key of the source file
 * @returns {Promise<string|null>}
 */
functions.getCoresidentImageUrlForKey = async (bucket, key) => {

  const { path, name } = utils.splitKeyToComponents(key);

  // Check possible extensions for a matching file
  for (let i = 0; i < DEFAULT_IMAGE_EXTENSIONS.length; i += 1) {
    const imageExtension = DEFAULT_IMAGE_EXTENSIONS[i];
    const probableImageKey = `${path}/${name}.${imageExtension}`;
    if (await s3.doesObjectExist(bucket, probableImageKey)) {

      // Make the file public
      await s3.makeFilePublic(bucket, probableImageKey);

      // Return a URL for the file
      return s3.createUrl(bucket, probableImageKey);
    }
  }

  return null;
};

/**
 * Attempts to import a file defined by the specified bucket/key
 * @param bucket the bucket in which the file resides
 * @param key the key at which the file resides
 * @param executionContext the execution context for this import
 * @returns {Promise<void>}
 */
functions.importFile = async (bucket, key, executionContext) => {
  console.log(`Attempting to import file [${key}]`);

  // Pre-create some tags for metrics
  const statsTags = [];
  statsTags.push(`org:${executionContext.org}`);
  statsTags.push(`environment:${executionContext.env}`);

  const startTime = new Date().getTime();
  try {

    // Get the metadata object that represents a composite of all default metadata files encountered
    //  for the key that we're processing
    const defaultMetadata = await metadata.getDefaultMetadata(bucket, key, executionContext);

    // Get the metadata object for the key
    const { path, name } = utils.splitKeyToComponents(key);
    const fileMetadata = await metadata.getMetadataForKey(bucket, `${path}/${name}.json`, executionContext);

    // Get any potential image file for the key
    const imageUrl = await functions.getCoresidentImageUrlForKey(bucket, key);

    // Compile the ANS that we want to POST to Video Center
    const videoAns = functions.createVideoAns(bucket, key, defaultMetadata, fileMetadata, imageUrl);
    console.log(`Final ANS: ${JSON.stringify(videoAns)}`);

    // Make the video file readable by Video Center
    await s3.makeFilePublic(bucket, key);

    // Post the video to Video Center
    await functions.postAnsToVideoCenter({
      domain: executionContext.importDomain,
      ans: videoAns,
      encode: true
    });

    stats.increment('success', 1, statsTags);

  } catch (err) {
    console.log(`There was an error processing key [${key}].\nError was: ${err}`);

    stats.increment('failure', 1, statsTags);
  }

  // Collect the call time
  const endTime = new Date().getTime();
  stats.increment('callTime', endTime - startTime, statsTags);
};

/**
 * Posts the ANS to Video Center.
 *
 * @param params
 */
functions.postAnsToVideoCenter = async (params) => {

  // Build the options
  const options = {
    url: `http://${params.domain}/goldfish/api/video/v2/import/ans?encode=${params.encode}`,
    json: true,
    method: 'POST',
    body: params.ans,
    auth: {
      bearer: process.env.ArcToken
    }
  };

  console.log(`Posting ANS to [${options.url}]`);

  await request(options);
};

module.exports = functions;
